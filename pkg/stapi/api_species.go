/*
 * STAPI
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package stapi

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type SpeciesApiService service

/* 
SpeciesApiService
Retrival of a single species
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uid Species unique ID
 * @param optional nil or *SpeciesGetOpts - Optional Parameters:
     * @param "ApiKey" (optional.String) -  API key

@return SpeciesFullResponse
*/

type SpeciesGetOpts struct { 
	ApiKey optional.String
}

func (a *SpeciesApiService) SpeciesGet(ctx context.Context, uid string, localVarOptionals *SpeciesGetOpts) (SpeciesFullResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SpeciesFullResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/species"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("uid", parameterToString(uid, ""))
	if localVarOptionals != nil && localVarOptionals.ApiKey.IsSet() {
		localVarQueryParams.Add("apiKey", parameterToString(localVarOptionals.ApiKey.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SpeciesFullResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SpeciesApiService
Pagination over species
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SpeciesSearchGetOpts - Optional Parameters:
     * @param "PageNumber" (optional.Int32) -  Zero-based page number
     * @param "PageSize" (optional.Int32) -  Page size
     * @param "ApiKey" (optional.String) -  API key

@return SpeciesBaseResponse
*/

type SpeciesSearchGetOpts struct { 
	PageNumber optional.Int32
	PageSize optional.Int32
	ApiKey optional.String
}

func (a *SpeciesApiService) SpeciesSearchGet(ctx context.Context, localVarOptionals *SpeciesSearchGetOpts) (SpeciesBaseResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SpeciesBaseResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/species/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiKey.IsSet() {
		localVarQueryParams.Add("apiKey", parameterToString(localVarOptionals.ApiKey.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SpeciesBaseResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SpeciesApiService
Searching species
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SpeciesSearchPostOpts - Optional Parameters:
     * @param "PageNumber" (optional.Int32) -  Zero-based page number
     * @param "PageSize" (optional.Int32) -  Page size
     * @param "Sort" (optional.String) -  Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
     * @param "ApiKey" (optional.String) -  API key
     * @param "Name" (optional.String) -  Species name
     * @param "ExtinctSpecies" (optional.Bool) -  Whether it should be an extinct species
     * @param "WarpCapableSpecies" (optional.Bool) -  Whether it should be a warp-capable species
     * @param "ExtraGalacticSpecies" (optional.Bool) -  Whether it should be an extra-galactic species
     * @param "HumanoidSpecies" (optional.Bool) -  Whether it should be a humanoid species
     * @param "ReptilianSpecies" (optional.Bool) -  Whether it should be a reptilian species
     * @param "NonCorporealSpecies" (optional.Bool) -  Whether it should be a non-corporeal species
     * @param "ShapeshiftingSpecies" (optional.Bool) -  Whether it should be a shapeshifting species
     * @param "SpaceborneSpecies" (optional.Bool) -  Whether it should be a spaceborne species
     * @param "TelepathicSpecies" (optional.Bool) -  Whether it should be a telepathic species
     * @param "TransDimensionalSpecies" (optional.Bool) -  Whether it should be a trans-dimensional species
     * @param "UnnamedSpecies" (optional.Bool) -  Whether it should be a unnamed species
     * @param "AlternateReality" (optional.Bool) -  Whether this species should be from alternate reality

@return SpeciesBaseResponse
*/

type SpeciesSearchPostOpts struct { 
	PageNumber optional.Int32
	PageSize optional.Int32
	Sort optional.String
	ApiKey optional.String
	Name optional.String
	ExtinctSpecies optional.Bool
	WarpCapableSpecies optional.Bool
	ExtraGalacticSpecies optional.Bool
	HumanoidSpecies optional.Bool
	ReptilianSpecies optional.Bool
	NonCorporealSpecies optional.Bool
	ShapeshiftingSpecies optional.Bool
	SpaceborneSpecies optional.Bool
	TelepathicSpecies optional.Bool
	TransDimensionalSpecies optional.Bool
	UnnamedSpecies optional.Bool
	AlternateReality optional.Bool
}

func (a *SpeciesApiService) SpeciesSearchPost(ctx context.Context, localVarOptionals *SpeciesSearchPostOpts) (SpeciesBaseResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SpeciesBaseResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/species/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiKey.IsSet() {
		localVarQueryParams.Add("apiKey", parameterToString(localVarOptionals.ApiKey.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExtinctSpecies.IsSet() {
		localVarFormParams.Add("extinctSpecies", parameterToString(localVarOptionals.ExtinctSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WarpCapableSpecies.IsSet() {
		localVarFormParams.Add("warpCapableSpecies", parameterToString(localVarOptionals.WarpCapableSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExtraGalacticSpecies.IsSet() {
		localVarFormParams.Add("extraGalacticSpecies", parameterToString(localVarOptionals.ExtraGalacticSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HumanoidSpecies.IsSet() {
		localVarFormParams.Add("humanoidSpecies", parameterToString(localVarOptionals.HumanoidSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReptilianSpecies.IsSet() {
		localVarFormParams.Add("reptilianSpecies", parameterToString(localVarOptionals.ReptilianSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NonCorporealSpecies.IsSet() {
		localVarFormParams.Add("nonCorporealSpecies", parameterToString(localVarOptionals.NonCorporealSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShapeshiftingSpecies.IsSet() {
		localVarFormParams.Add("shapeshiftingSpecies", parameterToString(localVarOptionals.ShapeshiftingSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceborneSpecies.IsSet() {
		localVarFormParams.Add("spaceborneSpecies", parameterToString(localVarOptionals.SpaceborneSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TelepathicSpecies.IsSet() {
		localVarFormParams.Add("telepathicSpecies", parameterToString(localVarOptionals.TelepathicSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransDimensionalSpecies.IsSet() {
		localVarFormParams.Add("transDimensionalSpecies", parameterToString(localVarOptionals.TransDimensionalSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnnamedSpecies.IsSet() {
		localVarFormParams.Add("unnamedSpecies", parameterToString(localVarOptionals.UnnamedSpecies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AlternateReality.IsSet() {
		localVarFormParams.Add("alternateReality", parameterToString(localVarOptionals.AlternateReality.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SpeciesBaseResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
