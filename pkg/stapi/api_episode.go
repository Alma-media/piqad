/*
 * STAPI
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package stapi

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type EpisodeApiService service

/* 
EpisodeApiService
Retrival of a single episode
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uid Episode unique ID
 * @param optional nil or *EpisodeGetOpts - Optional Parameters:
     * @param "ApiKey" (optional.String) -  API key

@return EpisodeFullResponse
*/

type EpisodeGetOpts struct { 
	ApiKey optional.String
}

func (a *EpisodeApiService) EpisodeGet(ctx context.Context, uid string, localVarOptionals *EpisodeGetOpts) (EpisodeFullResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EpisodeFullResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/episode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("uid", parameterToString(uid, ""))
	if localVarOptionals != nil && localVarOptionals.ApiKey.IsSet() {
		localVarQueryParams.Add("apiKey", parameterToString(localVarOptionals.ApiKey.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v EpisodeFullResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EpisodeApiService
Pagination over episodes
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EpisodeSearchGetOpts - Optional Parameters:
     * @param "PageNumber" (optional.Int32) -  Zero-based page number
     * @param "PageSize" (optional.Int32) -  Page size
     * @param "ApiKey" (optional.String) -  API key

@return EpisodeBaseResponse
*/

type EpisodeSearchGetOpts struct { 
	PageNumber optional.Int32
	PageSize optional.Int32
	ApiKey optional.String
}

func (a *EpisodeApiService) EpisodeSearchGet(ctx context.Context, localVarOptionals *EpisodeSearchGetOpts) (EpisodeBaseResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EpisodeBaseResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/episode/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiKey.IsSet() {
		localVarQueryParams.Add("apiKey", parameterToString(localVarOptionals.ApiKey.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v EpisodeBaseResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EpisodeApiService
Searching episodes
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EpisodeSearchPostOpts - Optional Parameters:
     * @param "PageNumber" (optional.Int32) -  Zero-based page number
     * @param "PageSize" (optional.Int32) -  Page size
     * @param "Sort" (optional.String) -  Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
     * @param "ApiKey" (optional.String) -  API key
     * @param "Title" (optional.String) -  Episode title
     * @param "SeasonNumberFrom" (optional.Int32) -  Minimal season number
     * @param "SeasonNumberTo" (optional.Int32) -  Maximal season number
     * @param "EpisodeNumberFrom" (optional.Int32) -  Minimal episode number in season
     * @param "EpisodeNumberTo" (optional.Int32) -  Maximal episode number in season
     * @param "ProductionSerialNumber" (optional.String) -  Production serial number
     * @param "FeatureLength" (optional.Bool) -  Whether it should be a feature length episode
     * @param "StardateFrom" (optional.Float32) -  Starting stardate of episode story
     * @param "StardateTo" (optional.Float32) -  Ending stardate of episode story
     * @param "YearFrom" (optional.Int32) -  Starting year of episode story
     * @param "YearTo" (optional.Int32) -  Ending year of episode story
     * @param "UsAirDateFrom" (optional.String) -  Minimal date the episode was first aired in the United States
     * @param "UsAirDateTo" (optional.String) -  Maximal date the episode was first aired in the United States
     * @param "FinalScriptDateFrom" (optional.String) -  Minimal date the episode script was completed
     * @param "FinalScriptDateTo" (optional.String) -  Maximal date the episode script was completed

@return EpisodeBaseResponse
*/

type EpisodeSearchPostOpts struct { 
	PageNumber optional.Int32
	PageSize optional.Int32
	Sort optional.String
	ApiKey optional.String
	Title optional.String
	SeasonNumberFrom optional.Int32
	SeasonNumberTo optional.Int32
	EpisodeNumberFrom optional.Int32
	EpisodeNumberTo optional.Int32
	ProductionSerialNumber optional.String
	FeatureLength optional.Bool
	StardateFrom optional.Float32
	StardateTo optional.Float32
	YearFrom optional.Int32
	YearTo optional.Int32
	UsAirDateFrom optional.String
	UsAirDateTo optional.String
	FinalScriptDateFrom optional.String
	FinalScriptDateTo optional.String
}

func (a *EpisodeApiService) EpisodeSearchPost(ctx context.Context, localVarOptionals *EpisodeSearchPostOpts) (EpisodeBaseResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EpisodeBaseResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/episode/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiKey.IsSet() {
		localVarQueryParams.Add("apiKey", parameterToString(localVarOptionals.ApiKey.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Title.IsSet() {
		localVarFormParams.Add("title", parameterToString(localVarOptionals.Title.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SeasonNumberFrom.IsSet() {
		localVarFormParams.Add("seasonNumberFrom", parameterToString(localVarOptionals.SeasonNumberFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SeasonNumberTo.IsSet() {
		localVarFormParams.Add("seasonNumberTo", parameterToString(localVarOptionals.SeasonNumberTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EpisodeNumberFrom.IsSet() {
		localVarFormParams.Add("episodeNumberFrom", parameterToString(localVarOptionals.EpisodeNumberFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EpisodeNumberTo.IsSet() {
		localVarFormParams.Add("episodeNumberTo", parameterToString(localVarOptionals.EpisodeNumberTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProductionSerialNumber.IsSet() {
		localVarFormParams.Add("productionSerialNumber", parameterToString(localVarOptionals.ProductionSerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FeatureLength.IsSet() {
		localVarFormParams.Add("featureLength", parameterToString(localVarOptionals.FeatureLength.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StardateFrom.IsSet() {
		localVarFormParams.Add("stardateFrom", parameterToString(localVarOptionals.StardateFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StardateTo.IsSet() {
		localVarFormParams.Add("stardateTo", parameterToString(localVarOptionals.StardateTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.YearFrom.IsSet() {
		localVarFormParams.Add("yearFrom", parameterToString(localVarOptionals.YearFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.YearTo.IsSet() {
		localVarFormParams.Add("yearTo", parameterToString(localVarOptionals.YearTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UsAirDateFrom.IsSet() {
		localVarFormParams.Add("usAirDateFrom", parameterToString(localVarOptionals.UsAirDateFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UsAirDateTo.IsSet() {
		localVarFormParams.Add("usAirDateTo", parameterToString(localVarOptionals.UsAirDateTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FinalScriptDateFrom.IsSet() {
		localVarFormParams.Add("finalScriptDateFrom", parameterToString(localVarOptionals.FinalScriptDateFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FinalScriptDateTo.IsSet() {
		localVarFormParams.Add("finalScriptDateTo", parameterToString(localVarOptionals.FinalScriptDateTo.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v EpisodeBaseResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
